#!/usr/bin/env bash
set -euo pipefail

# Usage: generate_htaccess_sorted.sh input_file [output_file]
if [[ $# -lt 1 || $# -gt 2 ]]; then
  echo "Użycie: $0 input_file [output_file]" >&2
  exit 1
fi

input_file="$1"
output_file="${2:-.htaccess}"

if [[ ! -f "$input_file" ]]; then
  echo "Plik wejściowy nie istnieje: $input_file" >&2
  exit 2
fi

# normalize_to_path: zwraca ścieżkę zaczynającą się od "/" i bez końcowego "/" (oprócz korzenia)
normalize_to_path() {
  local url="$1"
  # usuń zewnętrzne cudzysłowy i trim
  url="${url%\"}"; url="${url#\"}"
  url="${url#"${url%%[![:space:]]*}"}"; url="${url%"${url##*[![:space:]]}"}"

  # jeżeli już jest ścieżką
  if [[ "$url" == /* ]]; then
    # usuń końcowy slash, chyba że to jedynie "/"
    [[ "$url" == "/" ]] && { echo "/"; return; }
    echo "${url%/}"
    return
  fi

  # jeżeli nie zawiera :// traktuj jako ścieżkę (dodaj wiodący / i usuń końcowy /)
  if [[ "$url" != *"://"* ]]; then
    [[ -z "$url" ]] && { echo "/"; return; }
    url="/${url#"/"}"
    echo "${url%/}"
    return
  fi

  # pełny URL -> wyciągnij część po pierwszym "/" po hostie
  local after_proto="${url#*://}"
  if [[ "$after_proto" == */* ]]; then
    local path="/${after_proto#*/}"
    [[ "$path" == "/" ]] && echo "/" || echo "${path%/}"
  else
    echo "/"
  fi
}

tmp_unsorted="$(mktemp)"
trap 'rm -f "$tmp_unsorted"' EXIT

while IFS= read -r rawline || [[ -n $rawline ]]; do
  line="${rawline#"${rawline%%[![:space:]]*}"}"
  line="${line%"${line##*[![:space:]]}"}"
  [[ -z "$line" || "${line:0:1}" == "#" ]] && continue

  if [[ "$line" == *","* ]]; then
    old_raw="${line%%,*}"
    new_raw="${line#*,}"
  else
    IFS=$' \t' read -r old_raw new_raw _ <<< "$line"
  fi

  old_raw="${old_raw%\"}"; old_raw="${old_raw#\"}"
  new_raw="${new_raw%\"}"; new_raw="${new_raw#\"}"
  old_raw="${old_raw#"${old_raw%%[![:space:]]*}"}"
  old_raw="${old_raw%"${old_raw##*[![:space:]]}"}"
  new_raw="${new_raw#"${new_raw%%[![:space:]]*}"}"
  new_raw="${new_raw%"${new_raw##*[![:space:]]}"}"

  lower_old="$(tr '[:upper:]' '[:lower:]' <<< "$old_raw")"
  lower_new="$(tr '[:upper:]' '[:lower:]' <<< "$new_raw")"
  if [[ "$lower_old" =~ ^(url|old|source|from)$ ]] || [[ "$lower_new" =~ ^(nowy|new|target|to)$ ]]; then
    continue
  fi

  [[ -z "$old_raw" || -z "$new_raw" ]] && { echo "Pomijam (brak pola): $rawline" >&2; continue; }

  old_path="$(normalize_to_path "$old_raw")"

  # Target: jeśli pełny URL zachowaj go; jeśli ścieżka - normalizuj ale NIE usuwaj protokołu (używamy normalize_to_path i usuwamy końcowy slash)
  if [[ "$new_raw" == *"://"* ]]; then
    # Dla pełnego URL zostaw bez zmian, ale usuń końcowy slash po ścieżce (np. https://a/b/ -> https://a/b)
    # rozbij na prefiks (protocol+host) i path
    proto_host="${new_raw%%/*}//${new_raw#*//}"
    # prostsze: usuń końcowy slash tylko jeśli nie jest samym "https://host/"
    # rozbicie: host_part = proto://host[:port], path_part = rest (opcjonalne)
    host_part="${new_raw%%/*://*}" # fallback, ale użyj bezpieczniejszego podejścia poniżej
    # lepsze: użyj parameter expansion
    after_proto2="${new_raw#*://}"
    host_only="${after_proto2%%/*}"
    if [[ "$after_proto2" == */* ]]; then
      path_part="/${after_proto2#*/}"
      path_part="${path_part%/}"
      new_target="${new_raw%%://${after_proto2}}://${host_only}${path_part}"
    else
      new_target="$new_raw"
    fi
  else
    new_target="$(normalize_to_path "$new_raw")"
  fi

  if [[ "$old_path" == "/" ]]; then
    plen=0
  else
    p="${old_path%/}"
    plen=${#p}
  fi

  printf '%s\t%s\t%09d\n' "$old_path" "$new_target" "$plen" >> "$tmp_unsorted"
done < "$input_file"

tmp_sorted="$(mktemp)"
sort -t$'\t' -k3,3nr -k1,1 "$tmp_unsorted" > "$tmp_sorted"

{
  echo "# Generated by generate_htaccess_sorted.sh on $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  echo "# Rules sorted: more specific (longer) paths first; root (/) emitted as RedirectMatch"
  echo
  while IFS=$'\t' read -r old_path new_target plen; do
    if [[ "$old_path" == "/" ]]; then
      printf 'RedirectMatch 301 ^/$ %s\n' "$new_target"
    else
      printf 'Redirect 301 %s %s\n' "$old_path" "$new_target"
    fi
  done < "$tmp_sorted"
} > "$output_file"

rm -f "$tmp_sorted" "$tmp_unsorted"
trap - EXIT
echo "Wygenerowano $output_file"
